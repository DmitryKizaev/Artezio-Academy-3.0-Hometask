"""Homework 3 Task 2"""

# Написать функцию, которая принимает произвольное количество
# любых аргументов. Аргументами могут быть вложенные списки
# и кортежи, содержащие числа и другие списки и кортежи.
# Пример вызова функции: foo(1, 2, [3, 4, (5, 6, 0)], a=(10, 11),
# b=(3, 4, [5, 6, [7, 8], []])) Функция должна вернуть произведение
# и сумму всех ненулевых элементов вложенных чисел. Возможны циклические ссылки
# в аргументах. Пример такого аргумента: a = [1, 2, 3]; a.append(a)
# При обнаружении циклической ссылки сообщить пользователю и вернуть None.

from pprint import isrecursive

# поскольку через аргументы по умолчанию передавать промежуточные результаты
# при рекурсии не можем - иначе будет путаница между аргументами по умолчанию
# и kwargs такими как a=(10, 11) - храним результаты в глобальных переменных

mult_arg = 1
sum_arg = 0

# возможно, не лучшее решение, но если быть аккуратным то всё должно быть ок


def sum_mult_lazy(*args, **kwargs):
    """Ленивая: решает задачу, но не убирает за собой глобальные переменные"""
    global mult_arg, sum_arg

    elements = list(args)  # собираем все аргументы в один список
    elements.extend(kwargs.values())
    # от kwargs типа a=(10, 11) берем только значения

    for i in elements:  # пробегаемся по всем полученным аргументам
        if isrecursive(i):  # нашли циклическую ссылку - стоп машина
            print("Cycle link in ", i, "found!")
            return None
        # нашли число - считаем
        if isinstance(i, (int, float)):
            if i != 0:
                sum_arg += i
                mult_arg *= i
        else:  # нашли коллекцию - углубляемся в нее
            sum_mult_lazy(*i)  # рекурсия
    return [sum_arg, mult_arg]


def sum_mult(*args, **kwargs):
    """Вспомогательная функция, обеспечивает многоразовость основной"""
    global mult_arg, sum_arg
    tmp = sum_mult_lazy(*args, **kwargs)  # считаем то что нам нужно
    mult_arg = 1
    sum_arg = 0
    # чтобы при рекурсии не сбивались промежуточные результаты, почистить
    # глобальные переменные можем только отдельной функцией,
    # когда основная полностью закончила свою работу
    return tmp


a = [1, 2, 3]
a.append(a)

print("Test 1")
print(sum_mult(1, 2, [3, 4, (5, 6, 0)],
               a=(10, 11), b=(3, 4, [5, 6, [7, 8], []])))
print("\nTest 2")
print(sum_mult(1, 2, a=[3, a, (5, 6, 5)], b=2))
